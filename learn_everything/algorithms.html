<!DOCTYPE html>
<html>

<head>
    <title>Algorithms</title>
    <link rel="stylesheet" href="styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="algorithms.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/themes/prism.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.26.0/prism.min.js"></script>
</head>

<body>

    <div id="container">
        <h1>Algorithms</h1>

        <h2>Introduction</h2>
        <ul>
            <li>Definition of an Algorithm</li>
            <li>Importance in Computer Science and Programming</li>
            <li>Types of Algorithms</li>
            <li>Characteristics of Good Algorithms</li>
        </ul>

        <h2>Sorting Algorithms</h2>
        <ul>
            <li>Bubble Sort
                <ul>
                    <li>How it Works</li>
                    <li>Time Complexity</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>Quick Sort
                <ul>
                    <li>How it Works</li>
                    <li>Time Complexity</li>
                    <li>Code Example</li>
                </ul>
            </li>
        </ul>

        <h2>Search Algorithms</h2>
        <ul>
            <li>Linear Search
                <ul>
                    <li>How it Works</li>
                    <li>Time Complexity</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>Binary Search
                <ul>
                    <li>How it Works</li>
                    <li>Time Complexity</li>
                    <li>Code Example</li>
                </ul>
            </li>
        </ul>
        <h2>Graph Algorithms</h2>
        <ul>
            <li>Breadth-First Search (BFS)
                <ul>
                    <li>How it Works
                        <p>Breadth-First Search (BFS) starts at a starting node and explores its neighbors before going
                            to the next level neighbors. It uses a queue to keep track of nodes to be explored.</p>
                    </li>
                    <li>Applications
                        <p>Used in a variety of applications such as network crawling, path finding, and social network
                            analysis.</p>
                    </li>
                    <li>
                        <canvas id="bfsCanvas" width="200" height="200"></canvas>
                    </li>
                    <li>Code Example
                        <pre>
                <code class="language-python">
// Python code example for BFS
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])

while queue:
    vertex = queue.popleft()
    if vertex not in visited:
    print(vertex, end=" ")
    visited.add(vertex)
    queue.extend(neighbor for neighbor in graph[vertex] if neighbor not in visited)

# Example usage
graph = {'A': ['B', 'C'], 'B': ['D', 'E'], 'C': ['F'], 'D': [], 'E': ['F'], 'F': []}
bfs(graph, 'A')
    </code>
                </pre>
                    </li>
                </ul>
            </li>

            <li>Depth-First Search (DFS)
                <ul>
                    <li>How it Works
                        <p>Depth-First Search (DFS) starts at a root node and explores as far as possible along each
                            branch before backtracking. It uses a stack to keep track of nodes to be explored.</p>
                    </li>
                    <li>Applications
                        <p>DFS is used in various applications such as maze solving, topological sorting, and cycle
                            detection in graphs.</p>
                    </li>
                    <li>Code Example
                        <pre><code class="language-python">
# Python code example for DFS
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()

    visited.add(start)
    print(start, end=" ")

    for neighbor in graph[start]:
        if neighbor not in visited:
        dfs(graph, neighbor, visited)

# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
dfs(graph, 'A')
                    </code></pre>
                    </li>
                </ul>
            </li>

            <li><a href="dijkstra.html">Dijkstra's Algorithm</a></li>
            <li>Bellman-Ford Algorithm
                <ul>
                    <li>How it Works</li>
                    <li>Applications</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>Kruskal's Algorithm
                <ul>
                    <li>How it Works</li>
                    <li>Applications</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>Prim's Algorithm
                <ul>
                    <li>How it Works</li>
                    <li>Applications</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>A* Search Algorithm
                <ul>
                    <li>How it Works</li>
                    <li>Applications</li>
                    <li>Code Example</li>
                </ul>
            </li>
            <li>Floyd-Warshall Algorithm
                <ul>
                    <li>How it Works</li>
                    <li>Applications</li>
                    <li>Code Example</li>
                </ul>
            </li>
        </ul>
        <h2>Dynamic Programming</h2>
        <ul>
            <li>Fibonacci Sequence
                <ul>
                    <li>Recursive Approach</li>
                    <li>Dynamic Programming Approach</li>
                    <li>Code Example</li>
                </ul>
            </li>
        </ul>

    </div>

</body>

</html>